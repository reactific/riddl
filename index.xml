<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Welcome on RIDDL Documentation</title><link>https://riddl.tech/</link><description>Recent content in Welcome on RIDDL Documentation</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><managingEditor>reid@reactific.com (Reid Spencer)</managingEditor><webMaster>reid@reactific.com (Reid Spencer)</webMaster><lastBuildDate>Wed, 01 Dec 2021 15:34:22 -0500</lastBuildDate><atom:link href="https://riddl.tech/index.xml" rel="self" type="application/rss+xml"/><item><title>riddlc options</title><link>https://riddl.tech/translation/options/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><author>reid@reactific.com (Reid Spencer)</author><guid>https://riddl.tech/translation/options/</guid><description>Introduction Like many other complex programs, riddlc implements a variety of commands, each with their own functionality and their own options. As there are overlaps
Options come and go as riddlc evolves. If you experience issues with the command line options, you can always run riddlc without any options and it will explain the options your version supports. Common Options Some options are common to all the commands.</description></item><item><title>Audience</title><link>https://riddl.tech/audience/</link><pubDate>Wed, 01 Dec 2021 15:34:22 -0500</pubDate><author>reid@reactific.com (Reid Spencer)</author><guid>https://riddl.tech/audience/</guid><description>Summary There are four kinds of readers of this documentation based on the intent of the reader. Accordingly, the documentation has sections for each kind of reader:
Domain Experts read and validate specification outputs for accuracy, correctness, and completeness. Authors are individuals who create system specifications using RIDDL.
Authors form the bridge between Domain Experts and Implementors. Implementors do the work of converting the RIDDL specification into a working software system.</description></item><item><title>Akka</title><link>https://riddl.tech/translation/akka/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><author>reid@reactific.com (Reid Spencer)</author><guid>https://riddl.tech/translation/akka/</guid><description>The goal of the Akka translator is to generate all the infrastructure code needed to support the domain(s) defined in the RIDDL input. While this does produce a working system, it also relieves developers of much of the repetitive, detail oriented infrastructure that is relatively boring compared to the business logic of the system.
This translator recognizes that its output will be co-mingled with the business logic output that developers are writing and keeps them separate.</description></item><item><title>Language Conventions</title><link>https://riddl.tech/language/conventions/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><author>reid@reactific.com (Reid Spencer)</author><guid>https://riddl.tech/language/conventions/</guid><description>Introduction Syntax conventions of RIDDL are very simple and lenient. The intended audience is business owners, business analysts, domain engineers, and software architects. It is intentionally simple and readable. The language is free in its formatting. It does not require indentation and its various constructs can be arranged on any line. RIDDL supports the definition of a variety of concepts taken directly from Domain Driven Design and the Unified Modeling Language as well as software architecture.</description></item><item><title>State</title><link>https://riddl.tech/language/hierarchy/domain/context/entity/state/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><author>reid@reactific.com (Reid Spencer)</author><guid>https://riddl.tech/language/hierarchy/domain/context/entity/state/</guid><description>The state definitions of an entity define the structure of the information that the entity retains as its current state.
Syntax Example The state of an entity is defined with the state keyword within the content of an entity definition, like this:
entity Car { type Propulsion = any of { ICE, Electric, Steam, Diesel, EMDrive } state Static is { wheels: Integer doors: Integer rightHandDrive: Boolean propulsion: Propulsion } } One of the primary purposes of an entity is to represent the characteristics of the entity with state information.</description></item><item><title>Terminals</title><link>https://riddl.tech/grammar/terminals/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><author>reid@reactific.com (Reid Spencer)</author><guid>https://riddl.tech/grammar/terminals/</guid><description>This file shows the definition of the terminal symbols, as productions, and grouped in categories:
(* Terminal symbol definitions in various categories *) Terminals = Punctuation | Options | Keywords | Predefined | Readability | Operators; Punctuation = asterisk | comma | colon | curlyOpen | curlyClose | dot | equals | ellipsis | ellipsisQuestion | plus | question | quote | roundOpen | roundClose | squareOpen | squareClose | undefined | verticalBar ; asterisk = &amp;#34;*&amp;#34;; comma = &amp;#34;,&amp;#34;; colon = &amp;#34;:&amp;#34;; curlyOpen = &amp;#34;{&amp;#34;; curlyClose = &amp;#34;}&amp;#34;; dot = &amp;#34;.</description></item><item><title>Descriptions</title><link>https://riddl.tech/language/common/descriptions/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><author>reid@reactific.com (Reid Spencer)</author><guid>https://riddl.tech/language/common/descriptions/</guid><description>The RIDDL syntax is simply a hierarchical arrangement of definitions. Each definition can have a description. Descriptions are used to generate documentation and follow markdown conventions.
Examples There are several ways to describe a definition. In each of the examples we attach a description to some domain named Foo. The definition is not important for our purposes here. Descriptions come after the definition using one of four phrases:</description></item><item><title>Options</title><link>https://riddl.tech/language/hierarchy/domain/context/entity/options/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><author>reid@reactific.com (Reid Spencer)</author><guid>https://riddl.tech/language/hierarchy/domain/context/entity/options/</guid><description>The optional entity kind prefix is a directive that suggests how the entity might handle its state and received messages. In the example above, we expect the &amp;ldquo;Printer&amp;rdquo; entity to be a physical device. An &amp;ldquo;actor&amp;rdquo; entity in of the same name could be expected to be a person who prints.
The options available suggest how the entity might handle its state and message input:
kind - indicates the intended kind of entity in an argument to the kind entity.</description></item><item><title>Root</title><link>https://riddl.tech/language/hierarchy/root/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><author>reid@reactific.com (Reid Spencer)</author><guid>https://riddl.tech/language/hierarchy/root/</guid><description>At the root (file) level you can only do two things: include definitions from another file or define a domain.
For example:
include &amp;#34;other-file&amp;#34; domain foo is { ??? } ```</description></item><item><title>Common</title><link>https://riddl.tech/grammar/common/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><author>reid@reactific.com (Reid Spencer)</author><guid>https://riddl.tech/grammar/common/</guid><description>A number of frequently used productions are useful to understand in the sections that follow. Commentary follows the grammar.
(* Common RIDDL EBNF Grammar Productions *) (******************************************************************** COMMON *) any char = ? any UTF-8 character ? ; any but newline = any char - ( &amp;#34;\n&amp;#34; | &amp;#34;\r&amp;#34; ) ; nonquote = any char - &amp;#39;&amp;#34;&amp;#39; ; digits = &amp;#34;0&amp;#34; | &amp;#34;1&amp;#34; | &amp;#34;2&amp;#34; | &amp;#34;3&amp;#34; | &amp;#34;4&amp;#34; | &amp;#34;5&amp;#34; | &amp;#34;6&amp;#34; | &amp;#34;7&amp;#34; | &amp;#34;8&amp;#34; | &amp;#34;9&amp;#34; ; literalInteger = digits literalString = quote nonquote quote ; literalStrings = literalString { literalString } ; markdownLine = verticalBar, any but newline, newline ; markdownLines= markdownLine { markdownLine.</description></item><item><title>Documentation Conventions</title><link>https://riddl.tech/introduction/conventions/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><author>reid@reactific.com (Reid Spencer)</author><guid>https://riddl.tech/introduction/conventions/</guid><description>This page defines the conventions we use throughout this documentation.
RIDDL Snippets Whenever we include RIDDL code in the documentation it will be in a fixed sized font like this:
domain MyDomain is { ??? } Extended Backus-Naur Form When RIDDL grammar definitions are made, we utilize the EBNF grammar meta-language to specify the grammar. You can read about this grammar meta-language on Wikipedia For example, here&amp;rsquo;s how EBNF can define a quoted string:</description></item><item><title>Hugo Docs</title><link>https://riddl.tech/translation/hugo/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><author>reid@reactific.com (Reid Spencer)</author><guid>https://riddl.tech/translation/hugo/</guid><description>One of the main features of the RIDDL compiler is generating HTML documentation. The documentation enjoys the advantage of being more complete and accurate due to the compiler&amp;rsquo;s rigorous correctness validations. The riddlc compiler generates Hugo sources for conversion to Hugo by the hugo generator</description></item><item><title>Invariants</title><link>https://riddl.tech/language/hierarchy/domain/context/entity/invariants/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><author>reid@reactific.com (Reid Spencer)</author><guid>https://riddl.tech/language/hierarchy/domain/context/entity/invariants/</guid><description>Invariants specify rules about the state of an entity that must never be violated. Invariants typically come from business logic assertions. For example, a business axiom of a warehouse might be that the supply of a product should never be below 1. That is, the warehouse should never completely run out of a product it is storing. Reality, of course, must account for the supply running out; nevertheless specifying an invariant on the business intent may be important.</description></item><item><title>Pipes</title><link>https://riddl.tech/language/hierarchy/domain/streaming/pipe/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><author>reid@reactific.com (Reid Spencer)</author><guid>https://riddl.tech/language/hierarchy/domain/streaming/pipe/</guid><description>Pipes are uni-directional conduits for reliably transmitting data of a particular type between the publishers and consumers attached at the ends of the pipe.
Syntax Example pipe WeatherForecast is { options rate(1000), paritions(7), transmits type Forecast } In the foregoing, a pipe named WeatherForecast is defined to transmit the data type named Forecast and with two options:
rate - an expected sustained rate of 1000 data points per second partitions - a minimum number of partitions on the data of 7 Data Transmission Type Pipes can transmit any data type that RIDDL can specify.</description></item><item><title>RBBQ Scenarios</title><link>https://riddl.tech/examples/scenario/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><author>reid@reactific.com (Reid Spencer)</author><guid>https://riddl.tech/examples/scenario/</guid><description>Case Study The Reactive BBQ restaurant chain has determined that their existing restaurant operations system is not suitably meeting their needs and have hired a high technology consulting company to provide some needed guidance on how they can improve their customer service, tracking, and reliability.
What follows are the interviews conducted with key personnel at Reactive BBQ in order to identify the issues.
CEO of Reactive BBQ How would you describe your restaurants?</description></item><item><title>Binary AST</title><link>https://riddl.tech/translation/bast/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><author>reid@reactific.com (Reid Spencer)</author><guid>https://riddl.tech/translation/bast/</guid><description>When the riddlc compiler parses a RIDDL document, it translates it to an Abstract Syntax Tree (AST) in memory. The AST is then used by other passes to validate and translate the AST into other forms. The binary AST (BAST) translator converts the AST in memory into a binary format that is stored for later usage. Saving the BAST format and then reading it back into the compiler avoids the time to both parse the RIDDL document and validate it for consistency.</description></item><item><title>Compilation</title><link>https://riddl.tech/introduction/compilation/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><author>reid@reactific.com (Reid Spencer)</author><guid>https://riddl.tech/introduction/compilation/</guid><description>Introduction The Riddl compiler performs several functions which are described in this section. There are several phases, as described in the following sections.
Lexical Analysis Riddl uses the excellent fastparse library by Li Haoyi. This phase parses the raw textual input to make sure it is syntactically correct. From that syntax, an abstract syntax tree (AST) is produced. Incorrect syntax leads to errors without further analysis.</description></item><item><title>Domain</title><link>https://riddl.tech/grammar/domain/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><author>reid@reactific.com (Reid Spencer)</author><guid>https://riddl.tech/grammar/domain/</guid><description>See domains for examples and explanations of the following grammar productions
(* RIDDL EBNF Grammar for knowledge domains *) domain include = &amp;#34;include&amp;#34;, literalString domain content = typeDef | topic | interaction | context | domain | domainInclude domain = &amp;#34;domain&amp;#34;, identifier, &amp;#34;is&amp;#34;, &amp;#34;{&amp;#34;, (undefined | domainContent), &amp;#34;}&amp;#34;, description</description></item><item><title>Examples</title><link>https://riddl.tech/language/common/examples/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><author>reid@reactific.com (Reid Spencer)</author><guid>https://riddl.tech/language/common/examples/</guid><description>RIDDL uses Gherkin examples in various places to express a functionality or behavior requirement on the definition that uses it. Gherkin examples are used in these places:
Adaptors Entity Handlers Functions Processors Saga Actions Story Structure Gherkin is a language developed by SmartBear Software, a vendor of software quality tools, for the cucumber testing system. RIDDL uses a subset of the language as SmartBear has defined it.</description></item><item><title>Processors</title><link>https://riddl.tech/language/hierarchy/domain/streaming/processor/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><author>reid@reactific.com (Reid Spencer)</author><guid>https://riddl.tech/language/hierarchy/domain/streaming/processor/</guid><description>As the name indicates, a RIDDL processor definition specifies the inputs and outputs of some processor of data. The inputs to the processor are declared with inlet statements and the outputs from the processor are declared with outlet statements.
Inlets An inlet statement in the definition of a processor provides the name and data type for an input to the processor. There can be multiple inlets to the processor but each one must have a separate inlet statement.</description></item><item><title>Projections</title><link>https://riddl.tech/language/hierarchy/domain/context/projections/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><author>reid@reactific.com (Reid Spencer)</author><guid>https://riddl.tech/language/hierarchy/domain/context/projections/</guid><description>Introduction A projection is a read-only view of entity information. Projections are necessary since entities use event sourcing which is not a query-friendly format.
Here&amp;rsquo;s the projection process. Usually, events are logged as they are kept appended at the end of the log file. Logs are string and text. To retrieving meaningful information out of logs, logs are transformed into a more query-friendly format and stored in queriable repository or DB.</description></item><item><title>Reactive BBQ</title><link>https://riddl.tech/examples/reactivebbq/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><author>reid@reactific.com (Reid Spencer)</author><guid>https://riddl.tech/examples/reactivebbq/</guid><description>domain ReactiveBBQ is { author is { name: &amp;#34;Reid Spencer&amp;#34; email: &amp;#34;reid@reactific.com&amp;#34; organization: &amp;#34;Reactific Software LLC&amp;#34; title: &amp;#34;President&amp;#34; url: http://reactific.com/ } include &amp;#34;restaurant/domain&amp;#34; include &amp;#34;backoffice/domain&amp;#34; include &amp;#34;corporate/domain&amp;#34; } explained as { |{{&amp;lt; figure src=&amp;#34;/images/RBBQ.png&amp;#34; &amp;gt;}} |A domain to encapsulate the entire enterprise named Reactive BBQ. |It is divided into three subdomains: |* Restaurant -- handles each of the restaurant locations |* Back Office -- handles all the back office supplies and menus |* Corporate -- handles the corporate web site, marketing, accounting and HR |This domain definition is designed to be instructive in the RIDDL language.</description></item><item><title>Types</title><link>https://riddl.tech/language/common/types/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><author>reid@reactific.com (Reid Spencer)</author><guid>https://riddl.tech/language/common/types/</guid><description>Introduction The RIDDL language allows users to define data types. Definitions of types are more limited in RIDDL than in programming languages on purpose. The type system must be easily understandable by non-programmers as the domain engineer or domain expert is likely the most frequent user.
Predefined Types RIDDL supports several predefined types that just &amp;ldquo;exist&amp;rdquo; because they are fundamental and well understood in any targeted computing environment.</description></item><item><title>Expressions</title><link>https://riddl.tech/language/common/expressions/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><author>reid@reactific.com (Reid Spencer)</author><guid>https://riddl.tech/language/common/expressions/</guid><description>RIDDL allows expressions to be specified in various places. Most frequently they are the operands to message constructors and when clauses in Gherkin examples. This page shows you what you can do with expressions in RIDDL.
Expressions Expressions compute values of arbitrary types. Since RIDDL is not a programming language, the syntax used for expressions is minimal and abstract. There is no attempt in RIDDL to be computationally complete.</description></item><item><title>Context</title><link>https://riddl.tech/grammar/context/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><author>reid@reactific.com (Reid Spencer)</author><guid>https://riddl.tech/grammar/context/</guid><description>DDD bounded contexts are represented in RIDDL with the context definition whose syntax is:
(* RIDDL EBNF Grammar for bounded contexts *) context options = options(&amp;#34;wrapper&amp;#34; | &amp;#34;gateway&amp;#34; | &amp;#34;function&amp;#34;) context include = &amp;#34;include&amp;#34;, literalString context definitions = typedef | entity | adaptor | interaction | contextInclude context = &amp;#34;context&amp;#34;, identifier, is, open, (undefined | context options, context definitions), close, description }</description></item><item><title>Features</title><link>https://riddl.tech/language/hierarchy/domain/context/features/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><author>reid@reactific.com (Reid Spencer)</author><guid>https://riddl.tech/language/hierarchy/domain/context/features/</guid><description>A Feature is a requirement on a context. Features are specified very similarly to the Gherkin language. The same keywords are used and the style is more like RIDDL syntax. If you&amp;rsquo;re already familiar with Gherkin then an example should suffice:
Feature &amp;#34;Guess the word&amp;#34; is { // The first example has two steps Scenario &amp;#34;Maker starts a game&amp;#34; is { When the Maker starts a game Then the Maker waits for a Breaker to join } // The second example has three steps Scenario &amp;#34;Breaker joins a game&amp;#34; is { Given the Maker has started a game with a word When the Breaker joins the Maker&amp;#39;s game Then the Breaker must guess a word knowing the length of the Maker&amp;#39;s word choice.</description></item><item><title>Includes</title><link>https://riddl.tech/language/common/includes/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><author>reid@reactific.com (Reid Spencer)</author><guid>https://riddl.tech/language/common/includes/</guid><description>An include statement is not a RIDDL definition but an instruction to the compiler to lexically replace the include statement with the content of another file. The name of the file to include is the statement&amp;rsquo;s only parameter, like this:
include &amp;#34;other-file.riddl&amp;#34; The include statement is only permitted where major definitions are expected, specifically at root level, and in the bodies of domain, context, entity, and pipe definitions.</description></item><item><title>OpenAPI</title><link>https://riddl.tech/translation/openapi/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><author>reid@reactific.com (Reid Spencer)</author><guid>https://riddl.tech/translation/openapi/</guid><description/></item><item><title>Plants</title><link>https://riddl.tech/language/hierarchy/domain/streaming/plant/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><author>reid@reactific.com (Reid Spencer)</author><guid>https://riddl.tech/language/hierarchy/domain/streaming/plant/</guid><description>A RIDDL plant is a definition that combines pipes with processors to specify a model of how data should flow. You may define as many plants as needed but each plant is a closed system without the ability of the RIDDL model to express the sharing of data between the plants. This is done deliberately to prevent unintentional contamination of data in large models.
Joints The purpose of a plant definition is to provide the blueprint for how a set of pipes, processors, and entities are joined together so that data may flow end-to-end.</description></item><item><title>Principles</title><link>https://riddl.tech/introduction/principles/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><author>reid@reactific.com (Reid Spencer)</author><guid>https://riddl.tech/introduction/principles/</guid><description>RIDDL is a high level system specification language and as such must obey some principles of such languages. This page provides those principles.
1: Declarative RIDDL is not an implementation language and does not pretend to be computationally complete. RIDDL adopts this what not how principle. Details are for software developers. The analyst or architect that writes RIDDL documents wants to only specify what the system is while abstracting away the process of constructing it.</description></item><item><title>Entity</title><link>https://riddl.tech/grammar/entity/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><author>reid@reactific.com (Reid Spencer)</author><guid>https://riddl.tech/grammar/entity/</guid><description>(* RIDDL EBNF Grammar For Entity definition *) entity = entity kind, &amp;#34;entity&amp;#34;, &amp;#34;is&amp;#34;, &amp;#34;{&amp;#34;, entity options, entity definitions, &amp;#34;}&amp;#34;, description ; entity kind = [ &amp;#34;device&amp;#34; | &amp;#34;actor&amp;#34; | &amp;#34;concept&amp;#34;] ; entity options = single option | multi options ; single-option = &amp;#34;option&amp;#34;, &amp;#34;is&amp;#34;, entity option kinds; multi-option = &amp;#34;options&amp;#34;, &amp;#34;(&amp;#34;, { entity option kinds }, &amp;#34;)&amp;#34;; entity option kinds = &amp;#34;event sourced&amp;#34; | &amp;#34;value&amp;#34; | &amp;#34;aggregate&amp;#34; | &amp;#34;persistent&amp;#34; | &amp;#34;consistent&amp;#34; | &amp;#34;available&amp;#34;; entity definition = handler | feature | function | invariant | typeDef | state; entity definitions = entity definition { entity definition } ; entity state = &amp;#34;state&amp;#34;, identifier, &amp;#34;is&amp;#34;, &amp;#34;{&amp;#34;, identifier, &amp;#34;is&amp;#34;, typeExpression, &amp;#34;}&amp;#34;, description State A state is defined with the state keyword in the content of an entity using this syntax:</description></item><item><title>Functions</title><link>https://riddl.tech/language/common/functions/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><author>reid@reactific.com (Reid Spencer)</author><guid>https://riddl.tech/language/common/functions/</guid><description>Introduction Functions are pieces of processing that can be attached to entity, consumer, and api definitions. A function has a set of inputs (its requirements) and a set of output (what it yields). Functions need not be pure and often have side effects through the state changes of an entity.
Example Here&amp;rsquo;s an example of a function, named riddle, that requires a Subject(String) type and returns a Riddle (String) type.</description></item><item><title>Handler</title><link>https://riddl.tech/language/hierarchy/domain/context/entity/handler/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><author>reid@reactific.com (Reid Spencer)</author><guid>https://riddl.tech/language/hierarchy/domain/context/entity/handler/</guid><description>A handler in an entity specifies how an entity handles its input messages.
Handlers are specified with the handler keyword and enclose a set of on clauses that specify what to do with a given event when that handler is active. There are four kinds of on clauses distinguished by the kind of message they handle (command, event, query, and reaction) as detailed in the following sections
Command Handler A command handler specifies which persistent event is generated for a given command.</description></item><item><title>Interactions</title><link>https://riddl.tech/language/common/interactions/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><author>reid@reactific.com (Reid Spencer)</author><guid>https://riddl.tech/language/common/interactions/</guid><description>Introduction An Interaction evolves from the concepts inherent in a UML Sequence Diagram. Instead of specifying those concepts in a visual way, as in UML, RIDDL specifies them in a textual way. The purpose of an interaction is to specify an important way in which the system components communicate and cooperate to accomplish a task that is valuable to the stakeholders of the system.
As with the UML concept, an interaction shows the message flow between system entities in time sequence.</description></item><item><title>Function</title><link>https://riddl.tech/language/hierarchy/domain/context/entity/functions/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><author>reid@reactific.com (Reid Spencer)</author><guid>https://riddl.tech/language/hierarchy/domain/context/entity/functions/</guid><description>TBD</description></item><item><title>Imports</title><link>https://riddl.tech/language/common/imports/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><author>reid@reactific.com (Reid Spencer)</author><guid>https://riddl.tech/language/common/imports/</guid><description>This feature is not implemented yet.
An import statement may be used to import a definition from a BAST file that was generated from a prior compilation. Import statements help to save time when a prior compilation has completed and been saved as a BAST file.</description></item><item><title/><link>https://riddl.tech/_footer/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><author>reid@reactific.com (Reid Spencer)</author><guid>https://riddl.tech/_footer/</guid><description>©2022 Reactific Software LLC. All Rights Reserved.</description></item><item><title/><link>https://riddl.tech/_header/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><author>reid@reactific.com (Reid Spencer)</author><guid>https://riddl.tech/_header/</guid><description>RIDDL Documentation</description></item><item><title/><link>https://riddl.tech/privacy-policy/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><author>reid@reactific.com (Reid Spencer)</author><guid>https://riddl.tech/privacy-policy/</guid><description>Static Web Site This is a static site. It does not use cookies, has no ability to collect your information, and does not invade your privacy. This site is merely for documentation that you may use as you see fit.</description></item><item><title>Contact Us</title><link>https://riddl.tech/contact/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><author>reid@reactific.com (Reid Spencer)</author><guid>https://riddl.tech/contact/</guid><description>TBD</description></item><item><title>Frequently Asked Questions</title><link>https://riddl.tech/introduction/faq/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><author>reid@reactific.com (Reid Spencer)</author><guid>https://riddl.tech/introduction/faq/</guid><description> Is RIDDL a programming language? No. RIDDL is a business and system specification language based on many ideas from domain driven design and reactive system architecture. RIDDL is not computationally complete. However, its compiler is capable of producing compilable code to automate the creation of the structure of a system.</description></item><item><title>Search Result</title><link>https://riddl.tech/search/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><author>reid@reactific.com (Reid Spencer)</author><guid>https://riddl.tech/search/</guid><description/></item></channel></rss>